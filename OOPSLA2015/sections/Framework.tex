\section{\name Implementation}

%\hl{A new section.}

\name is implemented using the standard Java annotations framework
(\lstinline{javax.annotation}) packaged in the Java Development Kit.
All of the generic traversals are automatically generated
by \name for Object Algebra interfaces annotated with \lstinline{@Algebra}.
When an Object Algebra interface is annotated with \lstinline{@Algebra}, \name retrieves the required information from the interface (such as the names and types of factory methods) using reflection. \name then generates the code based on the templates shown earlier.
Furthermore, the \name framework includes the \lstinline{Monoid} interface as well as several
useful implementations of it.


A major advantage of using standard Java annotations is that the code generation of the generic traversals can be done transparently: users do not need to use or install a tool to generate that code. As a result \name is as simple to use as a conventional library.
With little configuration effort, the code generation is automatically enabled in IDEs like Eclipse or IntelliJ. Finally, the framework is very small (around 885 source lines of code), so it can be easily be customized, if needed.


%With \name framework, the code users need to write is much shorter, which can be observed from the number of methods. Suppose a data structure consists of $m$ constructors, and $n$ operations are applied to the structure. A traditional OO implementation defines $m$ classes for the constructors, and for operations, $n$ methods are implemented in each class. With Object Algebras, $n$ classes serve for operations, and each includes $m$ methods for all cases. The same number of classes are required with \name approach, nonetheless, only the monoid and the interesting part (usually one or several cases) are to be implemented for each operation, which makes the code much more concise.

\begin{comment}
Another advantage of \name is that it is quite easy to extend with new
types of traversals.
\bruno{Say something about this}

\tijs{It's this many SLOC:  885}
\bruno{Should we talk about code size? How big is the \name framework?}
\end{comment}
\begin{comment}
To address this problem, we provide a framework \name, which utilizes \emph{Java Annotation} to generate query and transformation interfaces based on the \emph{Object Algebra Interface}. For the below code:
\begin{lstlisting}[numbers=none]
@Algebra
public interface ExpAlg<Exp> {
	Exp Var(String s);
	Exp Lit(int i);
	Exp Add(Exp e1, Exp e2);
}
\end{lstlisting}
with the annotation "$@$Algebra", the framework will generate the boilerplate codes for us automatically. As for our ExpAlg example, the following directory structure will be generated by the library.

\dirtree{%
 .1 src/.
 .2 query/.
 .3 ExpAlgQuery.
 .3 G\_ExpAlgQuery.
 .2 transform/.
 .3 ExpAlgTransform.
 .3 G\_ExpAlgTransform.
}

Here the automatically generated ExpAlgQuery, G\_ExpAlgQuery, ExpAlgTransform and G\_ExpAlgTransform are exactly the same code as we discussed in the previous sections. Developers can implement interesting methods by inheriting from these generic classes without worrying about the traversing work.


With our framework \name, when programming with query and
transformations, the programmer can skip the intermediate steps such
as constructing generic queries and transformations, but only focus on
rewriting the interesting cases. For instance, in our ExpAlg example,
to implement FreeVars algebra, we can simply override the
\lstinline{Exp Var(String s)} method of \lstinline{class ExpAlgQuery}
to return variable name, and provide the specific monoid needed, which
in this case will be a \lstinline{StringListMonoid}. While the
SubstVars algebra can be realized by overriding the \lstinline{Exp
  Var(String s)} method of ExpAlgTransform interface, which
substitutes variable names as specified.
\end{comment}
