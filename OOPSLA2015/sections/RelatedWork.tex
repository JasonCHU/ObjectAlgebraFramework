\section{Related Work}\label{sec:related}

%To the best of our knowledge, our work proposes the first solution
%working entirely on a mainstream OO languages, that deals with the
%problem boilerplate code in traversals.

Structure-shy traversals have been an active research topic.  Our
approach to structure shy traversal is unique in that it supports
separate compilation, modular type checking and data type
extension. Furthermore, it can be applied in mainstream languages such
as Java. While some approaches support some of these features, to the
best of our knowledge, no approach supports all of them.

\paragraph{Adaptive Object-Oriented Programming (AOOP)}
AOOP is an extension of object-oriented programming
aimed at increasing the flexibility and maintainability of
programs~\cite{DemeterBook}. AOOP promotes the idea of structure-shyness to achieve those
goals. In AOOP it is possible to select parts of a structure that
should be visited. This is useful to do traversals on complex
structures and focus only on the interesting parts of the structure
relevant for computing the final output. The original approach to AOOP
was based on a domain-specific language~\cite{DemeterBook}. DJ is an
implementation of AOOP in Java using reflection~\cite{DJ}. More
recently DemeterF~\cite{OOGP} improved previous approaches to AOOP by
providing support for type-safe traversals, generics and data-generic
function generation. \name shares with AOOP the use of
structure-shyness as a means to increase flexibility and adaptability
of programs.  Most AOOP approaches, however, are not type-safe. The
exception is DemeterF where a custom type system was designed to
ensure type-safety of generic functions. Unlike DemeterF, which is a
separate language, \name is a Java library.  Moreover, compilation of
DemeterF programs is implemented through static weaving, and thus appears to
preclude separate compilation.

\paragraph{Strategic Programming}

Strategic programming is an approach to data structure traversal,
which originated in term
rewriting. Visser et al. extended the rewriting strategies of~\cite{borovansky1996elan} with generic one-level traversal operators~\cite{Visser:1998:BPO:289423.289425} enabling a style of term rewriting where computations are represented by simple, conditional rewrite rules, but
the application of such rules is controlled separately using the
concept of a strategy.  Strategies can be primitive (e.g., ``fail'')
or composed using combinators (e.g., ``try $s$ else $s'$'').  
These and other combinators were formalized in a  core language for strategic rewriting in~\cite{visser1998core}.

The
strategy concept have since then been ported to other paradigms.
\textsc{JJTraveler} is an OO framework for strategic
programming~\cite{visser01visitor}.  L\"ammel et al. introduced typed
strategy combinators in Haskell~\cite{lammel2002typed}. The relation
between strategic programming and AOOP has been explored
in~\cite{lammel2003strategic}. 

The key tenet of strategic programming is separation of concerns:  actual computation and traversal are specified separately.
In \name, the traversal of a data structure is also specified separately (in a super-interface), however, it is fixed for specific styles of queries and transformations.
For instance, both queries and transformations employ an innermost, bottom-up strategy.

The distinction between queries and transformations also originates from existing work in strategic programming.
L\"ammel et al.~\cite{lammel2002typed} discuss type unifying and type preserving traversals.
Type unifying traversals correspond to queries, where all data type constructors are unified into a single monoid.
Analogously, \name transformations are type preserving in the sense that a transformation is an algebra which maps constructor calls to another algebra of the same type.
%\tijs{Bruno: can you check the previous sentence? Should we mention ``type preserving'' natural transformations?}

The \textsc{Asf+Sdf} program transformation system distinguishes transforming and accumulating traversals, which correspond to our transformations and queries, respectively~\cite{vandenBrand:2003:TRT:941566.941568}.
Furthermore, an \textit{accumulating transforming} traversal combines both styles, by tupling the accumulated result and the transformed tree.
This combination could easily be generated by \name by having the boilerplate code construct the monoid and the transformed term in parallel (see Fig.~\ref{FIG:accuTrafo}).

\begin{figure}[t]
\nocaptionrule
\begin{lstlisting}[mathescape=true]
  interface AccuTrafoExp<M,E> extends
      ExpAlg<Pair<M,E>> {
    Monoid<M> m(); ExpAlg<E> expAlg();
    default Pair<M,E> Var(String s) {
      return new Pair<>(m().empty(),
          expAlg().Var(s));
    }
    default Pair<M,E> Lit(int i) {
      return new Pair<>(m().empty(),
          expAlg().Lit(i));
    }
    default Pair<M,E> Add(Pair<M,E> e1, Pair<M,E> e2)
    {
      return new Pair<>(m().join(e1.fst(), e2.fst()),
          expAlg().Add(e1.snd(), e2.snd()));
    }
  }
\end{lstlisting}
\caption{Combining query and transformation.}
\label{FIG:accuTrafo}
\end{figure}

\paragraph{Structure-Shy Traversals with Visitors}
A standard way to remove boilerplate in OOP is to use \emph{default
  visitors}~\cite{nordberg96variations}. Default visitors can be used
in similar ways to our generic traversals. Many programmers using
the visitor pattern create such default visitor implementations to
avoid boilerplate code. There are two important differences to
our work. Firstly conventional visitors are not extensible in a
type-safe way. Secondly, with \name the code for generic traversals
is automatically generated, whereas with default visitors such code
usually has to be implemented by hand.

Visser~\cite{visser01visitor} adapted the strategy combinators of Stratego~\cite{visser1998core,Visser:1998:BPO:289423.289425} to combinators that operate on object-oriented Visitors~\cite{gof}.
The resulting framework \textsc{JJTraveler} solves the problem of entangling traversal control within the \lstinline{accept} methods, or in the Visitors themselves (which only allow static specialization).
A challenge not addressed by \textsc{JJTraveler} is type safety of traversal code: either the combinators needs to be redefined for each data type, or client code needs to cast the generic objects of type \lstinline{AnyVisitable} to the specific type.
Even if specific combinators would be generated, however, the traversed data types would not be extensible.
%Furthermore, a performance evaluation based on counting cyclomatic complexity of medium-to-large Cobol programs, showed that the overhead of dispatch between various combinators accounts for roughly 7.5 slow-down~\cite{SPE:SPE616}.

Another approach to improve upon the standard Visitor pattern is presented in Palsberg et al.~\cite{palsberg98essence}.
This work particularly addressed the fact that traditional Visitors operate on a fixed set of classes. As a result, the data type can not be extended without changing all existing Visitors as well.
The proposed solution is a generic \lstinline{Walkabout} class which accesses sub-components of arbitrary data structures using reflection.
Unfortunately, the heavy use of reflection make \lstinline{Walkabout}s significantly slower than traditional Visitors.
The authors  state that the \lstinline{Walkabout} class could be generated to improve performance, but note that the addition of a class could trigger regeneration. As a result the pattern does not support separate compilation.
Our solution obtains the same kind of default behavior for traversal,  without losing extensibility, type safety, or separate compilation.

Whereas the \lstinline{Walkabout} provides generic navigation over an object structure, this navigation can be programmed explicitly using \textit{guides}~\cite{bravenboer2001guiding}.
Guides insert one level of indirection between recursing on the children of a node in \lstinline{visit} methods: the guide decides how to proceed the traversal.
Since guides needs to define how to proceed for each type that will be visited, they suffer from the same extensibility problem
as ordinary Visitors.
Generic guides, on the other hand, are dynamically typed and use reflection to call appropriate \lstinline{visit} methods.
The \lstinline{Walkabout} can be formulated as such a generic guide.

%Since the publication of the \lstinline{Walkabout} \cite{palsberg98essence} Java reflection had improved considerably; nevertheless Bravenboer et al. substantially improved its performance by caching reflective method lookups.



%However, such work has not addressed the problem of how to
%eliminate boilerplate in traversals. Our work shows that the
%combination of Object Algebras representing basic forms of traversals
%(queries and transformations) and standard OO inheritance provides a
%solution to the traversal boilerplate problem.

\paragraph{Structure-Shy Traversals in Functional Programming}
In
functional programming there has been a lot of research on type-safe
structure-shy traversals. L\"ammel and Peyton Jones' ``Scrap your
Boilerplate'' (SyB)~\cite{ralf03syb,lammel04syb,lammel05syb} series
introduced a practical design pattern for doing generic
traversals in Haskell. The simple queries and transformations in
\name were partly inspired by SyB. However SyB and \name use very
different implementation techniques. SyB is implemented in Haskell and
relies on a run-time type-safe cast mechanism. This approach allows
SyB traversals to be encoded once-and-forall using a single
higher-order function called {\small\texttt{gfoldl}}.
In contrast, in \name
Java annotations are used to generate generic traversals for each
structure.

A drawback of SyB traversals is that they are notoriously
slow, partly due to the use of the run-time
cast~\cite{adams2012tyb}. Another notable difference between SyB and
\name is with respect to extensibility. While \name supports
extensibility of both traversals and structures, the original SyB
approach did not support any extensibility. Only in later work,
L\"ammel and Peyton Jones proposed an alternative design for SyB,
based on type classes~\cite{wadler89type-classes}.
This design supports extensibility of traversals, but not of the
traversed structures.

\begin{comment}
In functional programming there has also been an important line of
work on \emph{datatype-generic programming} (DGP)~\cite{Gibbons07dgp}.  DGP is an
advanced form of \emph{generic programming}~\cite{GP}, where generic
functions are usually defined by inspecting the structure of
types.  Different approaches to DGP in Haskell have been extensively studied and documented~\cite{ComparingGPHaskellRodriquez,ComparingGPHaskellHinze}.
DGP can be used to implement structure-shy traversals as combinators,
similar to the traversals provided by SyB~\cite{hinze2003fun}.
Bringert~\cite{bjorn08acf}
introduced a DGP approach that can also be used to express queries
and transformations.
\end{comment}
Closest to \name is an approach proposed by
L\"ammel et al.~\cite{lammel00dealing} for dealing with the so-called
``\emph{large bananas}''. A large banana corresponds to the fold
algebra of a complex structure. Object Algebras, which we use in our
work, are an OO encoding of fold algebras~\cite{Oliveira08visitor,bruno12oa}.
However L\"ammel et al. work has not dealt with extensibility. Interestingly
in their future work  L\"ammel et al. did mention that they would like ``to cope
with incomplete or extensible systems of datatypes''.

%\tijs{Bruno: should we add this one: \cite{lammel2002typed}}


\begin{comment}
In that
approach for generalized and basic folds. These fold algebras scale up
applications involving large systems of mutually recursive
datatypes. These works all try to optimize traversal control of large
structures in functional programming paradigm, while our work solves a
similar problem in Object Algebras, a programming style in Object
Oriented Programming paradigm.
\end{comment}

\paragraph{Language Extensions for Queries}
Inspired by XPath/XQuery there has been some work on
adding support for similar types of queries on object-oriented
structures. For example the work on $C\omega$~\cite{BiermanMS05} extends
C\# with generalized member access, which allows simple
XPath-like path expressions. Thus in $C\omega$ it is possible
to express queries quite concisely. However, in contrast to \name
$C\omega$ is a language extension and it does not deal with transformations.

\paragraph{Eliminating Boilerplate in Design Patterns}
Design patterns~\cite{gof} improve the design and modularity of
object-oriented programs. However, the implementation of design
patterns sometimes requires significant amounts of boilerplate code. There has been
some work on implementing design patterns in AspectJ to achieve
reusability and modularity~\cite{Hannemann:2002:DPI:582419.582436},
and thus eliminate some of the boilerplate code. A challenge with
traditional design patterns, however, is that the boilerplate code is
not always mechanical, due to many possible implentation choices.
Our work proposes 
a number of design patterns for traversals. Because implementing these 
design patterns by hand would be quite tedious, we automatically
generate the code for such design patterns using \name. Fortunatelly, in contrast 
to many of the traditional design patterns, the code for 
generic traversals is highly regular and easy to generate, and can be
completely eliminated.  



\paragraph{Object Algebras} \name traversals are based on
Object Algebras~\cite{bruno12oa}. The original motivation for object
algebras was as a design pattern for OO programming that allowed
improved extensibility and modularity of programs.  Using object
algebras it is possible to solve the well-known ``Expression
Problem''~\cite{wadler98expression-problem}.  Later
work~\cite{oliveira13fop,rendel14attributes} has explored the use of
\emph{Object Algebra combinators}, and generalizations of object
algebras to improve expressiveness and modularity. In particular it
has been claimed that Object Algebras can be used to do
\emph{feature-oriented programming}~\cite{oliveira13fop}, and to
encode \emph{attribute grammars}~\cite{rendel14attributes}. One domain
where Object Algebras are especially useful is in the implementation
of (extensible) languages.  The QL language used in our case study is
based on Gouseti et al.~\cite{gouseti14extensible}. That work
provides a realistic implementation of an extensible
\emph{domain-specific language} using Object Algebras. In contrast to
our work, which focus on removing boilerplate code, previous work on Object Algebras was mostly motivated by
improved programming support for extensibility and modularity.
\begin{comment}
Our
work shows that Object Algebras are also useful to solve a different
problem: how to traverse complex structures without boilerplate
code.
\end{comment}
The combination of extensibility (inherited for free from Object
Algebras) and structure-shy type-safe traversals  adds a new
dimension to our work that, as far as we know, has not been explored
previously.

