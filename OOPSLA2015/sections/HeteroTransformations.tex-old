\section{Desugaring Transformations}\label{sec:heterotrans}

%\hl{A new section.}

In Section~\ref{sec:transformations}, we presented transformations, as well as the generic traversals generated by \name. Although different constructors can be used in transforming a data structure, the generic transformations generated by \name are type-preserving: they transform structures over one type (e.g., expressions) to different structures in the same type.

Desugaring transformations eliminate syntactic constructs by transforming them to a combination of constructs in a smaller base language. In this section we describe how \Name can be applied to implement compositional desugarings in a type-safe and extensible manner. In particular, the type system will enforce that the resulting language is indeed ``smaller'', and that consequently the desugared construct is guaranteed to be fully eliminated.

As an example, consider extending \lstinline{ExpAlg} with a doubling construct which multiplies its argument expression by two. The Object Algebra interface that implements doubling is defined as follows:

\lstinputlisting[linerange=6-9]{../ObjectAlgebras/src/trees/DoubleAlg.java} % APPLY:linerange=DOUBLE_TREE

An expression \lstinline{Double(e)} can be desugared to \lstinline{Add(e,e)}.
The following code realizes this transformation by extending the  \lstinline{ExpAlgTransform} interface, generated by \Name:

\lstinputlisting[linerange=7-11]{../ObjectAlgebras/src/example_DoubleAlg2/Desugar.java} % APPLY:linerange=DESUGAR_DOUBLE_SHY

The interface \lstinline{Desugar} exports the language \lstinline{DoubleAlg} and \lstinline{ExpAlg}, but \lstinline{expAlg()} (which is used as a factory for output expressions) has type \lstinline{ExpAlg}. Since \lstinline{ExpAlg} does not contain \lstinline{Double}, the \lstinline{Double} constructor cannot be used to construct the output. As a result, the algebra \lstinline{Desugar} transforms into is guaranteed to be without any occurrences of \lstinline{Double}.

Expressions are created over the combined languages \lstinline{DoubleAlg} and \lstinline{ExpAlg}:
\lstinputlisting[linerange=9-12]{../ObjectAlgebras/src/example_DoubleAlg2/Test.java} % APPLY:linerange=MAKE_DOUBLE_EXP


To illustrate the use of the \lstinline{Desugar} algebra, here is the code to print an expression in desugared form:

\lstinputlisting[linerange=17-24]{../ObjectAlgebras/src/example_DoubleAlg2/Test.java} % APPLY:linerange=PRINT_DESUGARED
%\bruno{This client code is strange! The mk methods be used to build expressions only. The Desugar algebra
%should not be inside.}

The kind of desugarings presented in this section are limited to bottom-up, compositional desugaring, corresponding to factory methods directly invoking methods in a different algebra. As a result, these desugarings are executed in a bottom-up fashion: the arguments are always desugared before an expression itself is transformed. Because the transformations are generic with respect to the carrier object of the argument (as indicated by the type parameter \lstinline{E}) it is impossible to look at the arguments. This prevents desugarings to perform complex, deep pattern matching on the argument structure. An added benefit, however, is that the desugaring is automatically deforested: intermediate expression trees are never created.
