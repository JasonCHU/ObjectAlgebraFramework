\section{Overview of \name}\label{subsec:overview}

This section starts by illustrating the problem of boilerplate code when implementing
traversals of complex structures. It then shows how \name addresses
the problem using a combination of Object Algebras~\cite{bruno12oa}
and Java annotations.

\subsection{Traversing Object-Oriented ASTs  }

%\haoyuan{Duplicate texts.}\\
%\haoyuan{One reference is missing.}\\
%\haoyuan{Style of presenting Java code.}

\begin{figure}[t]
\nocaptionrule
\begin{lstlisting}[language=ql]
form DriverLicense {
  name: "What is your name?" string
  age: "What is your age?" integer
  if (age >= 18) 
    license: "Have a driver's license?" boolean
}
\end{lstlisting}
\caption{Example QL questionnaire: driver's license}
\label{driver_license}
\end{figure}


We start by introducing the problem boilerplate code by considering a simplified variant of the QL language used in our case study~\cite{gouseti14extensible}.
Just like QL, miniQL can be used to describe interactive questionnaires. An example is shown in Figure~\ref{driver_license}.
The questionnaire first asks for the user's name and age, and then, if the age is greater than or equal to 18, asks if the user has a driver's license.
Because of the conditional construct, the last question only will appear when the user is actually eligible to have driver's license.

MiniQL's abstract syntax contains forms, statements (if-then and question) and expressions (only literals, variables and greater-than-or-equal).
A traditional OO implementation is shown in Figure~\ref{ql_oo_approach}. 
A form has a name and consists of a list of statements.
Conditionals contain an expression and a statement body. Expressions are standard. 

%In the full QL structure, an identified \lstinline{Form} comprises a list of \lstinline{Statements}. Each \lstinline{Statement} can either be a question (a variable depending on users' input or assigned with an \lstinline{Expression}) or a condition statement. Furthermore, an \lstinline{Expression} is based on several primitive types, and is obtained from certain values, variables, together with some possible arithmetic operations. In this section, the simplified version of QL has only six constructors.

The code in Figure~\ref{ql_oo_approach} also shows a query over MiniQL structures, namely the collection of used variables.
The operation is defined using the method \lstinline{usedVars}, declared in the abstract superclases  \lstinline{Stmt} and \lstinline{Exp}, and implemented in each concrete statement and expression. 
As can be seen, the only interesting bit of code is the \lstinline{usedVars} method in class \lstinline{Var}.
All other implementations merely deal with aggregating results of their child nodes.

The boilerplate code exhibited in the \lstinline{usedVars} query also applies to transformations.
Consider for example a rename transformation which takes a \lstinline{Form} and returns another form where all variables are renamed.
Again, the only interesting case is in the \lstinline{Var} class, where the actual renaming is applied. All other classes, however, require boilerplate to recreate the structure.
The full code in Appendix~\ref{subsec:appendix_code_oo_approach} contains a simple example of such a rename as well. 

%Two operations are supported by the QL structure: collecting the set of used variables in the questionnaire; and renaming all variables with an underscore ``\_'' appended to the end. To support those operations, an OO solution is to have methods \lstinline{usedVars}, which returns a set of strings representing used variables, and \lstinline{rename}, which updates the names of all variables in a questionnaire.
%\haoyuan{Clarify the differences between our solution and a usual OO approach.}

\begin{figure}[t]
\nocaptionrule
\lstinputlisting[linerange=122-166]{../ObjectAlgebras/src/example_QLAlg1/QL.java} % APPLY:linerange=OO_APPROACH_SIMP
\caption{A traditional OO implementation of the miniQL AST in Java including an operation to collect used variables (slightly abbreviated for presentation purposes; the full code is available in Appendix~\ref{subsec:appendix_code_oo_approach}).}
\label{ql_oo_approach}
\end{figure}

%Fig.~\ref{ql_oo_approach} shows the Java implementation of this OO approach. In the implementation, collecting the set of used variables is done by returning the variable name in instances of the \lstinline{Var} class, and delegating the method \lstinline{usedVars} to the child nodes in other classes. Renaming variables asks the instances of the \lstinline{Question} and \lstinline{Var} classes to do the renaming task, and similarly, other classes just delegates the method \lstinline{rename}. The renaming operation updates some information stored in the private members of those classes.

In addition to the significant amount of boilerplate code, there is another  drawback to the traditional OO solution, which is that it does  does not support extensibility along the dimension of operations. Each new operation requires pervasive change across the AST classes.
[lead out]

\subsection{Modeling MiniQL with Object Algebras}\label{subsec:model_ql_with_oa}


\begin{figure}[t]
\nocaptionrule
\lstinputlisting[linerange=7-15]{../ObjectAlgebras/src/trees/QLAlg.java} % APPLY:linerange=QL_TREE
\caption{Object Algebra interface of the MiniQL abstract syntax}
\label{ql_tree}
\end{figure}

Fig.~\ref{ql_tree} shows how  to model the abstract syntax of MiniQL
using an Object Algebra interface. Each kind of node (\lstinline{Exp}, \lstinline{Stmt}, \lstinline{Form})
is represented as a type parameter (\lstinline{E}, \lstinline{S}, and \lstinline{F} respectively).
Each method in the interface represents a data variant
constructo. For example the
method \lstinline{form} constructs an instance of a form; whereas the
method \lstinline{question} creates an instance of a question statement.
%From an
%object-oriented perspective the methods in the interface are factory
%methods.
%For the reader familiar with functional programming, the
%resemblance to constructors of  (a system of) algebraic data types should be clear.

Operations are defined by implementing the object algebra interface. \hl{Appendix~\ref{subsec:appendix_code_usedvars} and \ref{subsec:appendix_code_rename} gives the complete code for an implementation.}
The following code shows the implementation of the used variables
operation partly.

\begin{figure}[t]
  \lstinputlisting[linerange=49-80]{../ObjectAlgebras/src/example_QLAlg2/UsedVars.java} % APPLY:linerange=QL_QUERY_ALG_SIMP
  \caption{Collect used variables based on the Object Algebra interface}
  \label{ql_usedvars}
\end{figure}

The \lstinline{UsedVars} class provides an implementation for each
of the methods in the object algebra interface, which defines the
overall used variables operation. Since the result of collecting those
variables is \lstinline{Set<String>}, all the type parameters are set to
that type. Most of the method implementations simply traverse the
child nodes and accumulate the variable names. That is the case, for
example, for \lstinline{form}. The only method implementation that does
something different is \lstinline{var}, which returns the name
argument.

For the renaming operation the result is itself a structure
with all variable names updated. The following code shows the
implementation:

\lstinputlisting[linerange=36-45]{../ObjectAlgebras/src/example_QLAlg2/Rename.java} % APPLY:linerange=QL_TRANSFORM_ALG_SIMP

The class \lstinline{Rename} is parameterized by three types,
which represent the kinds of nodes in the QL structure. Each
constructor needs to build an instance of the right type of nodes.
Note that, due to the lack of better type-inference in Java, there is
some repetition of type-annotations. In order to create the updated
QL structure another algebra called \lstinline{alg} is used.
Almost all the method implementations reconstruct the structure with
no changes using the methods in \lstinline{alg}. Two exceptions are the
methods \lstinline{question} and \lstinline{var}, where the structure is also reconstructed, but
the names are modified with ``\_'' appended to the end.

Although we solved the problem of extensibility with object
algebras, the traversal code is still lengthy and we are still writing
tedious traversal code. In those two operations, the only interesting code
is in the methods \lstinline{question} and \lstinline{var}. Ideally, we would like to write only
the code for the interesting cases, and somehow ``inherit'' the
remainder tedious traversal code.

\subsection{\Name: An Object Algebra Framework for Traversals}

To deal with the boilerplate problem we created \Name: a Java object
algebras framework, which provides a number of generic traversals at
the cost of a simple annotation. The key idea in \name is to
automatically create highly generic object algebras, which encapsulate
common types of traversals. In particular \name supports generic
\emph{queries} and \emph{transformations}. Those two types of
traversals are useful to capture, respectively, the used variables and
renaming operations.

\begin{figure}[t]
\nocaptionrule
\lstinputlisting[linerange=10-17]{../ObjectAlgebras/src/example_QLAlg3/UsedVars.java} % APPLY:linerange=QL_QUERY_WITH_OAFRAMEWORK
\lstinputlisting[linerange=7-16]{../ObjectAlgebras/src/example_QLAlg3/Rename.java} % APPLY:linerange=QL_TRANSFORM_WITH_OAFRAMEWORK
\vspace{-.1in}
\caption{Used variables and renaming with \Name.}
\label{ql_with_oaframework}
\end{figure}

With \Name, programmers just need to add the \lstinline{@Algebra} annotation
to the definition of \lstinline{QLAlg} to get the code for generic
queries and transformations. An example of that annotation is already
shown in Fig.~\ref{ql_tree}. With that annotation several classes
are generated automatically, including \lstinline{QLAlgQuery} and
\lstinline{QLAlgTrans}. \hl{The generated code is available in Appendix~\ref{subsec:appendix_code_qlalgquery} and \ref{subsec:appendix_code_qlalgtransform}. And the implementation of \lstinline{SetMonoid} in \ref{subsec:appendix_code_setmonoid}.} Using those classes the code needed to write
the used variables and renaming object algebras is much
shorter. The code for the two operations is shown in
Fig.~\ref{ql_with_oaframework}. By implementing the
\lstinline{QLAlgQuery} and \lstinline{QLAlgTrans} classes, only the methods
\lstinline{question} and \lstinline{var} needs to be overridden: all the other methods,
which do a simple generic traversal, are inherited. For queries the
only extra thing a programmer has to do is to provide an instance of a
monoid, which is used to specify how to accumulate the results during
the traversal. Similarly, for transformations, the programmer needs to
pass an algebra for providing the constructors for the transformation
code.

Some client code is shown as follows: %, using those two algebras based on our framework.

\lstinputlisting[linerange=11-22]{../ObjectAlgebras/src/example_QLAlg3/Test.java} % APPLY:linerange=CLIENTCODE_MAKEQL

This method is used to create a particular QL structure, in the
usual object algebras style.
Using this QL structure, we can use the \lstinline{UsedVars}
and \lstinline{Rename} to compute some information about the questionnaire:

\lstinputlisting[linerange=27-31]{../ObjectAlgebras/src/example_QLAlg3/Test.java} % APPLY:linerange=CLIENTCODE_QLTEST

The results give \lstinline{[age]} and \lstinline{[age_]}, which
is respectively the set of used variables before and after renaming.

The remainder of the paper provides the details and implementation
techniques used in \Name. Besides basic queries and transformations,
\name also supports two generalizations of these types of traversals
called \emph{generalized queries} and \emph{contextual transformations}.

