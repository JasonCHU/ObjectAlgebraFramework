\section{Object Algebras}\label{subsec:ObjectAlgebras}

Object Algebras is a design pattern targeted to solve the famous Expression Problem, in the sense that this programming model supports extensibility in two dimensions of both data variants and operations, without sacrificing extensibility. We use object algebras to model the tree structures in this paper and it shows the ability to depict complex tree structures with flexibility and extensibility. The following section gives a brief introduction to object algebras.

\begin{figure}[t]
\nocaptionrule
\lstinputlisting[linerange=4-6]{../ObjectAlgebras/src/example_object_algebras/ObjectAlgebras.java} % APPLY:linerange=INT_ALG_INTERFACE
\caption{Int Alg Interface}
\label{int_alg_interface}
\end{figure}

Fig.~\ref{int_alg_interface} is an \emph{object algebra interface} which models \lstinline{lit} and \lstinline{add} expressions of \lstinline{IntAlg}. The \lstinline{object algebra interface} resembles abstract factory, but it adds an extra layer of abstraction in terms of the generics defined with the interface. Thus the developers have the flexibility of delay the specification of the type of objects produced by the factory to later stages.

\begin{figure}[t]
\nocaptionrule
\lstinputlisting[linerange=16-29]{../ObjectAlgebras/src/example_object_algebras/ObjectAlgebras.java} % APPLY:linerange=EXP_FACTORY
\caption{Exp Factory}
\label{exp_factory}
\end{figure}

\begin{figure}[t]
\nocaptionrule
\lstinputlisting[linerange=33-43]{../ObjectAlgebras/src/example_object_algebras/ObjectAlgebras.java} % APPLY:linerange=INT_PRINT
\caption{Int Print Factory}
\label{int_print_factory}
\end{figure}

An \emph{object algebra} is a class implementing an \emph{object algebra interface}. Fig.~\ref{exp_factory} extends the \lstinline{IntAlg} to be \lstinline{IntFactory}, which represents Expressions as a form of integers. This retroactive implementation of interfaces is commonly used in \emph{object algebras} to extend operations, as mentioned as one dimension of extensibility of Expression Problem. Fig.~\ref{int_print_factory} gives another example of extending \lstinline{IntAlg} with pretty printing operations.

\begin{figure}[t]
\nocaptionrule
\lstinputlisting[linerange=49-59]{../ObjectAlgebras/src/example_object_algebras/ObjectAlgebras.java} % APPLY:linerange=OA_TEST_CODE
\caption{Object Algebra Test Code}
\label{oa_test_code}
\end{figure}

As shown in Fig.~\ref{oa_test_code}, \emph{object algebras} provides a very generic method of writing code with \emph{object algebra interfaces}, and later instantiate objects with specific \emph{object algebras}.

Another dimension of extensibility can be realized by extending the original \emph{object algebra interface} with new data variants. Fig.~\ref{int_bool_alg_interface} extends the original \lstinline{IntAlg} with Boolean variables, and the extended \emph{object algebra interface} can be further extended with proper operations in the same fashion as we discussed previously.

In summary, \emph{object algebras} introduces \emph{object algebra interfaces} as generic models to depict abstract structures. Extending the \emph{object algebra interface} allows developers to introduce new data variants to the original structure, while implementing methods of \emph{object algebra interfaces} with specific class parameters give developers flexibility of extending new operations. What makes \emph{object algebras} a useful design pattern even more is that it does not rely on any advanced language features, and it is both extensible and type-safe.

\begin{figure}[t]
\nocaptionrule
\lstinputlisting[linerange=10-12]{../ObjectAlgebras/src/example_object_algebras/ObjectAlgebras.java} % APPLY:linerange=INT_BOOL_ALG_INTERFACE
\caption{Int Bool Alg Interface}
\label{int_bool_alg_interface}
\end{figure}

\begin{comment}

This paper showed how various types of traversals for complex
structures can be automatically provided by \Name. \name traversals are
written directly in Java and are type-safe, extensible and separately
compilable. There has always been a tension between the
correctness guarantees of static typing, and the flexibility of
untyped/dynamically-typed approaches. \name shows that even
in type systems like Java's, it is possible to get considerable
flexibility and adaptability for the problem of boilerplate code in
traversals of complex structures, without giving up modular static typing.
%\name offers the best of both worlds: the
%static typing guarantees; and flexibility and adaptability.

There are many of avenues for future work. One area of research is to
extend \name traversals to support flexible traversal strategies,
similarly to strategic
programming~\cite{borovansky1996elan,visser1998core,vandenBrand:2003:TRT:941566.941568}. Another
line of work worth exploring is to adopt generalizations of object
algebras~\cite{oliveira13fop} for added expressiveness of \name
traversals.

\end{comment}