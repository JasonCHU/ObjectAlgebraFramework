\section{Object Algebras Framework}

Generic queries, generalized generic queries, generic transformations and contextual generic transformations can help users write tree structure traversal code with more extensibility and flexibility. However, writing the generic query and transformation interfaces is still painful experience itself. Ideally the boilerplate code for tree structure traversal should be generated automatically so the developers can always focus on methods with interesting things. If we pay more attention to our 4 query and transformation interfaces, without much difficulty we can find that the query and transform code structures for all \emph{Object Algebra Interfaces} share much similarity. Therefore we can make this code generation process automatic. 

To address this problem, we provide a framework \name, which utilizes \emph{Java Annotation} to generate query and transformation interfaces based on the \emph{Object Algebra Interface}. For the below code: 
\begin{lstlisting}[numbers=none] 
@Algebra
public interface ExpAlg<Exp> {
	Exp Var(String s);
	Exp Lit(int i);
	Exp Add(Exp e1, Exp e2);
}
\end{lstlisting}
with the annotation "$@$Algebra", the framework will generate the boilerplate codes for us automatically. As for our ExpAlg example, the following directory structure will be generated by the library.

\begin{comment}
\dirtree{%
 .1 src/.
 .2 query/.
 .3 ExpAlgQuery.
 .3 G\_ExpAlgQuery.
 .2 transform/.
 .3 ExpAlgTransform.
 .3 G\_ExpAlgTransform.
}
\end{comment}

Here the automatically generated ExpAlgQuery, G\_ExpAlgQuery, ExpAlgTransform and G\_ExpAlgTransform are exactly the same code as we discussed in the previous sections. Developers can implement interesting methods by inheriting from these generic classes without worrying about the traversing work.

Furthermore, the monoid interface is also included in the \emph{Object Algebra Framework}. Hence users can design monoids inheriting from our generic monoid. 

With our framework \name, when programming with query and transformations, the programmer can skip the intermediate steps such as constructing generic queries and transformations, but only focus on rewriting the interesting cases. For instance, in our ExpAlg example, to implement FreeVars algebra, we can simply override the \lstinline{Exp Var(String s)} method of \lstinline{class ExpAlgQuery} to return variable name, and provide the specific monoid needed, which in this case will be a \lstinline{StringListMonoid}. While the SubstVars algebra can be realized by overriding the \lstinline{Exp Var(String s)} method of ExpAlgTransform interface, which substitutes variable names as specified. 
