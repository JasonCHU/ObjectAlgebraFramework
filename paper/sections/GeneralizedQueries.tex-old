\section{Generalized Queries}\label{sec:generalizedQueries}

The previous section discusses simple queries that contribute to the same type of monoid. However, recursive data type often have multiple syntactic categories, for instance expressions and statements.
In such many-sorted Object Algebras each sort is represented by the a different type parameter in the Object Algebra interface.
In this section we present \textit{generalized queries}, where each such type parameter can be instantiated to different monoids. 
The queries presented in the previous section are a special case of generalized queries when there is only a single sort.


\subsection{Dealing with multiple sorts}\label{subsec:depGraph}

%\tijs{I don't think we need the non-monoid example here, it's too much rehashing of earlier material, --- let's go immediately to the monoid version (Fig. 14).}
A simple example of a generalized query is the  construction of a data dependency between assignment statements and variables in simple imperative programs.

The simple ExpAlg is extended with statements using the StatAlg interface of Fig.~\ref{statalg}.
The extension consists of statement constructors for sequential composition and assignment.
A default implementation of queries over statements is shown in Fig.~\ref{LST:gstatquery}.
Note that the interface declares two monoids,---one for each sort.
Since the \lstinline{Assign} and \lstinline{Seq} constructors create statements, they return elements of the \lstinline{mStat()} monoid.
Furthermore, because it is impossible to automatically compose a monoid over one type with a monoid over another type, the \lstinline{p1} argument in \lstinline{Assign} is ignored.
As a result, a concrete implementation has to override this case to provide semantics for each transition from expressions into statements. 

\begin{figure}[t]
\lstinputlisting[linerange=7-10]{../ObjectAlgebras/src/trees/StatAlg.java} % APPLY:linerange=STATALG
\vspace{-.1in}
\caption{Statement Algebra Interface}
\label{statalg}
\end{figure}


\begin{figure}[t]
\lstinputlisting[linerange=7-11]{../ObjectAlgebras/src/deps2/G_StatAlgQuery.java} % APPLY:linerange=GSTAT_QUERY
\vspace{-.1in}
\caption{Default implementation of queries over many-sorted statement algebra}
\label{LST:gstatquery}
\end{figure}

\subsection{Example: data dependencies}

An example of a query over the many-sorted statement algebra is the extraction of data dependencies from a program.
Data dependencies are created by assignment statements:
for a statement \lstinline{Assign(String x, Exp e)} method, the variable \lstinline{x} will depend on all variables appearing in \lstinline{e}.
The result of extracting such dependencies can be represented as binary relation (a set of pairs). 

To implement the extraction of data dependencies only two case have to be implemented: the variable (\lstinline{Var}) case from the \lstinline{ExpAlg} signature, and the assignment (\lstinline{Assign}) case from the \lstinline{StatAlg} signature.
The implementation is shown in Fig.\ref{deps2}.
Note that the \lstinline{Assign} case takes in the input \lstinline{Set<String> p1} and uses it to create the binary dependency relation.
The propagation of the statement monoid across sequential composition is automatic, as is the propagation of the set of variables through expressions.


\begin{figure}[tb]
\lstinputlisting[linerange=12-17]{../ObjectAlgebras/src/deps2/DepGraph.java} % APPLY:linerange=DEPS2
\vspace{-.1in}
\caption{Dependency Graph with Generalized Query Algebra}
\label{deps2}
\end{figure}

The difference between generalized queries and homogeneous queries is that each type parameter of an Object Algebra interface is possibly instantiated to a different monoid.
If each parameter is instantiated to the same monoid, generalized queries are equivalent to the queries of the previous section, with one important difference: in the latter case, each sort is contributing to the same monoid.
The default implementation thus can carry over, for instance, query results of expression into the result of statements. 
