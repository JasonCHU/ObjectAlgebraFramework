\section{Generalized Queries}\label{sec:generalizedQueries}

The previous section discusses simple queries that contribute to the same type of monoid. However, recursive data type often have multiple syntactic categories, for instance expressions and statements.
In such many-sorted Object Algebras each sort is represented by the a different type parameter in the Object Algebra interface.
In this section we present \textit{generalized queries}, where each such type parameter can be instantiated to different monoids. 
The queries presented in the previous section are a special case of generalized queries when there is only a single sort.


\subsection{Dealing with multiple sorts}\label{subsec:depGraph}

%\tijs{I don't think we need the non-monoid example here, it's too much rehashing of earlier material, --- let's go immediately to the monoid version (Fig. 14).}
A simple example of a generalized query is the  construction of a data dependency between assignment statements and variables in simple imperative programs.

The simple ExpAlg is extended with statements using the StatAlg interface of Fig.~\ref{statalg}.
The extension consists of statement constructors for sequential composition and assignment.
A default implementation of queries over statements is shown in Fig.~\ref{LST:gstatquery}.
Note that the interface declares two monoids,---one for each sort.
Since the \lstinline{Assign} and \lstinline{Seq} constructors create statements, they return elements of the \lstinline{mStat()} monoid.
Furthermore, because it is impossible to automatically compose a monoid over one type with a monoid over another type, the \lstinline{p1} argument in \lstinline{Assign} is ignored.
As a result, a concrete implementation has to override this case to provide semantics for each transition from expressions into statements. 

\begin{figure}[t]
\lstinputlisting[linerange=7-10]{../ObjectAlgebras/src/trees/StatAlg.java} % APPLY:linerange=STATALG
\vspace{-.1in}
\caption{Statement Algebra Interface}
\label{statalg}
\end{figure}


\begin{figure}[t]
\lstinputlisting[linerange=7-11]{../ObjectAlgebras/src/deps2/G_StatAlgQuery.java} % APPLY:linerange=GSTAT_QUERY
\vspace{-.1in}
\caption{Default implementation of queries over many-sorted statement algebra}
\label{LST:gstatquery}
\end{figure}

\subsection{Example: data dependencies}

An example of a query over the many-sorted statement algebra is the extraction of data dependencies from a program.
Data dependencies are created by assignment statements:
for a statement \lstinline{Assign(String x, Exp e)} method, the variable \lstinline{x} will depend on all variables appearing in \lstinline{e}.
The result of extracting such dependencies can be represented as binary relation (a set of pairs). 


As shown above, if we introduce two monoids, \lstinline{mExp} and \lstinline{mStat}, it is simple to query and construct the desired dependency graph with monoids specific to the query types.  

Now that we have the Generalized queries with various monoids, we can focus on the interesting cases for constructing dependency graph and let the generalized query interface worry about the boilerplates. 

\begin{figure}[tb]
\lstinputlisting[linerange=12-17]{../ObjectAlgebras/src/deps2/DepGraph.java} % APPLY:linerange=DEPS2
\vspace{-.1in}
\caption{Dependency Graph with Generalized Query Algebra}
\label{deps2}
\end{figure}

Fig.~\ref{deps2} shows the code of constructing dependency graph with generalized queries. Similar to simple queries, to specify the desired return type of dependency graph, the developer only needs to clarify the monoids for each type argument. 

\begin{lstlisting}[numbers=none]
class StringPairDepGraph implements DepGraph {
	public Monoid<Set<String>> mExp() {return new SetMonoid<>();}
	public Monoid<Set<Pair<String, String>>> mStat() {
		return new SetMonoid<>();}
}
\end{lstlisting}

Note that the generalized query interface can be implemented with different ways to achieve different desired functionalities and monoids will help specify various query return types. 
