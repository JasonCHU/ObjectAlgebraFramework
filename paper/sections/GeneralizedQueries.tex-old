\section{Generalized Queries}\label{sec:generalizedQueries}
The previous section discusses simple queries of merging the same type. However, queries can be with different types when various type parameters are passed to the \textit{Object Algebra Interface}. Such generalized version of queries are applicable in more cases and the queries in the previous section is a special case of it. 

\subsection{Dependency Graph: Query different types}\label{subsec:depGraph}
A simple example of generalized queries could be to construct the dependency graph of a program. Let us first extend our simple ExpAlg to a more generalized language StatAlg by adding Statements as in Fig.~\ref{statalg}. Two more statements, sequence and assign operation, are added to our statement language. 

\begin{figure}[tb]
\lstinputlisting[linerange=-]{} % APPLY:linerange=7-10STATALG
\vspace{-.1in}
\caption{Statement Algebra Interface}
\label{statalg}
\end{figure}

Now think about constructing the dependency graph from a statement. For \lstinline{Assign(String x, Exp e)} method, the variable \lstinline{x} will depend on all variables appear in the Expression \lstinline{e}. As for \lstinline{Seq(Stat s1, Stat s2)}, it is nothing but merge the dependency list appear at both statement dependency lists. A simple implementation of constructing a dependency graph with return type \lstinline{Set<Pair<String, String>>} is shown in Fig.~\ref{deps1}. Here \lstinline{Var(String p0)} is the source where variable are created, and \lstinline{Assign(String p0, Set<String> p1)} describes that all variable in p1 are dependent on variable p0. Other methods only congregate same type of variables to larger collections. 

\begin{figure}[tb]
\lstinputlisting[linerange=-]{} % APPLY:linerange=12-27DEPS1
\vspace{-.1in}
\caption{Dependency Graph}
\label{deps1}
\end{figure}

Similar to what we have discussed in Section~\ref{sec:queries}, the traversal code contains boilerplates and it is natural to simplify this kind of traversal code in a similar way. 

\subsection{Generalized Queries with Monoids}\label{subsec:generalizedQuery}
The generalized queries such as constructing the dependency graph as discussed in \ref{subsec:depGraph} share a lot of similarities. Methods like \lstinline{Add(Exp e1, Exp e2)} and \lstinline{Seq(Stat s1, Stat s2)} can be easily implemented with the help of Monoids, but since generalized queries contain different type arguments, different monoids shall be specified to merge elements with corresponding types. 

\jason{The example implementing two interfaces seperately is not good as \lstinline{mExp()} in G\_StatAlgQuery is not actually used.}
\begin{comment}
\begin{lstlisting}[numbers=none]
public interface G_StatAlgQuery<A0, A1> extends StatAlg<A0, A1>, ExpAlg<A0> { 
	Monoid<A0> mExp();
	Monoid<A1> mStat();
	default A0 Add(A0 p0, A0 p1) {
		A0 res = mExp().empty();
		res = mExp().join(res, p0);
		res = mExp().join(res, p1);
		return res;
	}
	default A0 Lit(int p0) {
		A0 res = mExp().empty();
		return res;
	}
	default A0 Var(java.lang.String p0) {
		A0 res = mExp().empty();
		return res;
	}
	default A1 Assign(java.lang.String p0, A0 p1) {
		A1 res = mStat().empty();
		return res;
	}
	default A1 Seq(A1 p0, A1 p1) {
		A1 res = mStat().empty();
		res = mStat().join(res, p0);
		res = mStat().join(res, p1);
		return res;
	}
}
\end{lstlisting}
\end{comment}


\begin{lstlisting}[numbers=none]
public interface G_StatAlgQuery<A0, A1> extends StatAlg<A0, A1> {
	Monoid<A0> mExp();
	Monoid<A1> mStat();
	default A1 Assign(java.lang.String p0, A0 p1) {
		A1 res = mStat().empty();
		return res;
	}
	default A1 Seq(A1 p0, A1 p1) {
		A1 res = mStat().empty();
		res = mStat().join(res, p0);
		res = mStat().join(res, p1);
		return res;
	}
}
public interface G_ExpAlgQuery<A0> extends ExpAlg<A0> {
	Monoid<A0> mExp();
	default A0 Add(A0 p0, A0 p1) {
		A0 res = mExp().empty();
		res = mExp().join(res, p0);
		res = mExp().join(res, p1);
		return res;
	}
	default A0 Lit(int p0) {
		A0 res = mExp().empty();
		return res;
	}
	default A0 Var(java.lang.String p0) {
		A0 res = mExp().empty();
		return res;
	}
}
\end{lstlisting}

\jason{I should explain more of the code, specifically, how various monoids work together and build large tree structures. What is the algorithm of defining default implementation in constructor methods With various typed arguments.}

As shown above, if we introduce two monoids, \lstinline{mExp} and \lstinline{mStat}, it is simple to query and construct the desired dependency graph with monoids specific to the query types.  

\subsection{Dependency Graph with Generalized Query Algebra}\label{subsec:DepGraphWithGeneralizedQuery}
Now that we have the Generalized queries with various monoids, we can focus on the interesting cases for constructing dependency graph and let the generalized query interface worry about the boilerplates. 

\begin{figure}[tb]
\lstinputlisting[linerange=-]{} % APPLY:linerange=12-20DEPS2
\vspace{-.1in}
\caption{Dependency Graph with Generalized Query Algebra}
\label{deps2}
\end{figure}

Fig.~\ref{deps2} shows the code of constructing dependency graph with generalized queries. Similar to simple queries, to specify the desired return type of dependency graph, the developer only needs to clarify the monoids for each type argument. 

\begin{lstlisting}[numbers=none]
class StringPairDepGraph implements DepGraph {
	public Monoid<Set<String>> mExp() {return new SetMonoid<>();}
	public Monoid<Set<Pair<String, String>>> mStat() {
		return new SetMonoid<>();}
}
\end{lstlisting}

Note that the generalized query interface can be implemented with different ways to achieve different desired functionalities and monoids will help specify various query return types. 