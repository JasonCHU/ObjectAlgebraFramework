\section{Transformations}\label{sec:transformations}
\label{retroimp}

Queries are a way to extract information from a data structure.
Transformations, on the other hand, allow data structures to be changed.
Just as with queries, we can distinguish code that deal with traversing the data structure from code that actually changes the structure.
In this section we show how to avoid most traversal boilerplate code in the context of transformations based on Object Algebras.


\subsection{SubstVars: a simple tranformation algebra}\label{subsec:substvars}

An simple example of a transformation algebra, based on the interface \lstinline{ExpAlg} is called substituting variables for expressions. A manual implementation based on Object Algebras is shown in Fig.~\ref{substvars_without_id}.

\begin{figure}[!htbp]
\lstinputlisting[linerange=4-10]{../ObjectAlgebras/src/expDemo2/SubstVarsExpAlg.java} % APPLY:linerange=SUBSTVARS_WITHOUT_ID
\vspace{-.1in}
\caption{A normal algebra-based approach for substVars}
\label{substvars_without_id}
\end{figure}

The variable to be substituted, and the expression to substitute for are captured by the methods \lstinline{x()} and \lstinline{e()} respectively. 
\lstinline{expAlg()} is an instance of \lstinline{ExpAlg} on which the transformation is based.
In other words, performing the substitution will build a structure in the algebra \lstinline{expAlg()}.

Again we observe the problem of traversal-only boilerplate code: the \lstinline{Lit} and \lstinline{Add} methods simply delegate to the base algebra \lstinline{expAlg()} without performing any computation.
This boilerplate code can be avoided by creating a super-interface containing default methods performing the traversal (shown in Fig.~\ref{generic_transform}).
A concrete transformation can then selectively override the cases of interest.
Variable substitution can now be implemented as shown in Fig.~\ref{substvars_with_id}.
In this case, only the  method \lstinline{Var()} is overridden.


\begin{figure}[t]
\lstinputlisting[linerange=4-9]{../ObjectAlgebras/src/expDemo3/ExpAlgTransform.java} % APPLY:linerange=GENERIC_TRANSFORM
\vspace{-.1in}
\caption{Traversal-only base interface for implementing transformations of expressions}
\label{generic_transform}
\end{figure}


\begin{figure}[t]
\lstinputlisting[linerange=4-7]{../ObjectAlgebras/src/expDemo3/SubstVarsExpAlg.java} % APPLY:linerange=SUBSTVARS_WITH_ID
\vspace{-.1in}
\caption{The transformation interface for substVars}
\label{substvars_with_id}
\end{figure}


To execute substitution, the \lstinline{SubstVarsExpAlg} should be subclassed (either anonymously or explicitly) with implementations for \lstinline{x()}, \lstinline{e()}, and \lstinline{expAlg()}.
The base algebra \lstinline{expAlg()} could for instance be an algebra for pretty printing the expression with the substitution applied.


%Another important characteristic is that we can apply several transformations to the data structure before a query. This pattern is called the \textit{transformation pipeline}. Since the transformation algebra \lstinline{ExpAlgTransform<Exp>} is a sub-interface of \lstinline{ExpAlg<Exp>}, it creates any instance with the same type as the \lstinline{expAlg()} inside. Therefore a programmer can define a number of transformation algebras, and compose them in sequence, like a nested structure. At the meantime, a query algebra is passed to the innermost \lstinline{expAlg()}. In that case, the query is traversed recursively throughout the pipeline and eventually derives a certain composite transformation algebra.


%The \lstinline{SubstVarsExpAlg} is still generic, yet something like a pretty printer can be passed to the \lstinline{expAlg()} inside as a query, to display the results. Hence at this moment, a programmer doesn't need to write boilerplate code for traversals. The identity approach and the pipeline of transformations provide users with a generic transformation like a template.
