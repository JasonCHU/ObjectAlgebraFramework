\section{Related Work}\label{sec:related}

%To the best of our knowledge, our work proposes the first solution 
%working entirely on a mainstream OO languages, that deals with the 
%problem boilerplate code in traversals. 

This section discusses related work. Our approach is unique in that: 
it works in Java; supports both separate compilation and modular 
type-checking, as well as extensibility; and it enjoys from structure 
shyness and adaptability. While some approaches support some of these 
features, no approach supports all of them. A detailed comparison
follows next.

\paragraph{Adaptive Object-Oriented Programming (AOOP)}
AOOP~\cite{DemeterBook} is an extension of object-oriented programming
aimed at increasing the flexibility and maintainability of
programs. AOOP promotes the idea of structure-shyness to achieve those
goals. In AOOP it is possible to select parts of a structure that
should be visited. This is useful to do traversals on complex
structures and focus only on the interesting parts of the structure
relevant for computing the final output. The original approach to AOOP
was based on a domain-specific language~\cite{DemeterBook}. DJ is an
implementation of AOOP in Java using reflection~\cite{DJ}. More
recently, inspired by AOOP, DemeterF~\cite{OOGP} improved on previous
approaches by providing support for type-safe traversals, generics and
data-generic function generation. \name shares with AOOP the use of
structure-shyness as a means to increase flexibility and adaptability
of programs.  Differently from \name most AOOP approaches are not
type-safe. Only in DemeterF a custom type system was designed to
ensure type-safety of generic functions. However DemeterF requires a
new language whereas \name is a Java library. Moreover the compilation
of DemeterF is done through static weaving, and appears to preclude
separate compilation.

\paragraph{Strategic Programming}

Strategic programming is an approach to data structure traversal which originated in term rewriting~\cite{borovansky1996elan,visser1998core,vandenBrand:2003:TRT:941566.941568}.
Computations are represented by simple, conditional rewrite rules, but the application of such rules is controlled separately using a strategy.
Strategies can be primitive (e.g., ``fail'') or composed using combinators (e.g., ``try $s$ else $s'$'').
The strategy concept has been ported to other paradigms. \textsc{JJTraveler} is an OO framework for strategic programming~\cite{visser01visitor}.
L\"ammel et al. introduced typed strategy combinators in Haskell~\cite{lammel2002typed}.
The relation between strategic programming and AOOP has been explored in~\cite{lammel2003strategic}.

Strategic programming's key tenet is separation of concerns:  actual computation and traversal are specified separately.
In \name, the traversal of a data structure is also specified separately (in a super-interface), however, it is fixed for specific styles of queries and transformations.
For instance, queries and basic transformations employ an innermost, bottom-up strategy, whereas contextual transformations are executed in a top-down fashion.
We leave expressing more complex traversal strategies as future work. 

The distinction between queries and transformations also originates from existing work in strategic programming. The \textsc{Asf+Sdf} program transformation system distinguished transforming and accumulating traversals, which correspond to our transformations and queries, respectively.
L\"ammel et. al~\cite{lammel2002typed} discuss type unifying and type preserving traversals.
Type unifying traversal corresponds to our queries, where all data type constructors are unified into a single monoid.
Analogously, \name transformations are type preserving in the sense that a transformation is an algebra which maps constructor calls to another algebra of the same type.
\tijs{Bruno: can you check the previous sentence? Should we mention ``type preserving'' natural transformations?}


\paragraph{Structure-Shy Traversals with Visitors}
Visser~\cite{visser01visitor} provided some visitor
combinators that can express interesting traversal strategies in the
{\sc visitor} pattern~\cite{gof}. We applies some similar idea like identity
transformation in simple transformation, but our work targets at
traversal control in Object Algebras.\bruno{Tijs}\bruno{More work: 
The essence of the visitor pattern, and follow-up work to improve 
performance.}

\cite{palsberg98essence}

\cite{bravenboer2001guiding}





%However, such work has not addressed the problem of how to
%eliminate boilerplate in traversals. Our work shows that the
%combination of object algebras representing basic forms of traversals
%(queries and transformations) and standard OO inheritance provides a
%solution to the traversal boilerplate problem.

\paragraph{Structure-Shy Traversals in Functional Programming.}

In
functional programming there has been alot of research on type-safe
structure-shy traversals. Lammel and Peyton Jones' ``Scrap your
Boilerplate'' (SyB)~\cite{ralf03syb,lammel04syb,lammel05syb} series
introduced a practical design pattern for doing generic
traversals. The simple queries and transformations in
\name were partly inspired by SyB. However SyB and \name use very
different implementation techniques. SyB is implemented in Haskell and
relies on a run-time type-safe cast mechanism. This approach allows
Syb traversals to be encoded once-and-forall using a single
higher-order function called \lstinline{gfoldl}. In contrast, in \name
Java annotations are used to generate generic traversals for each
structure. A drawback of SyB traversals is that they are notoriously
slow, partly due to the use of the run-time
cast~\cite{adams2012tyb}. Another notable difference between SyB and
\name is with respect to extensibility. While \name supports
extensibility of both traversals and structures, the original SyB
approach did not support any extensibility. Only in later work,
L\"ammel and Peyton Jones proposed an alternative design for SyB,
based on type classes~\cite{wadler89type-classes}, that supported
extensibility of traversals. Nevertheless, the extensibility of the
traversed structures was not supported.

In functional programming there has also been an important line of
work on \emph{datatype-generic programming} (DGP)~\cite{Gibbons07dgp}.  DGP is an
advanced form of \emph{generic programming}~\cite{GP}, where generic
functions are usually defined by inspecting the structure of
types.  Extensive surveys of various approaches to DGP in Haskell
(mostly focused on libraries) document various
approaches~\cite{ComparingGPHaskellRodriquez,ComparingGPHaskellHinze}.
DGP can be used to implement structure-shy traversals as combinators,
similarly to the traversals provided by SyB~\cite{hinze2003fun}. 
Some DGP approaches have also been targetted specifically at doing 
structure-shy type-safe traversals. Bringert~\cite{bjorn08acf}
introduced a DGP approach that can also be used to express queries 
and transformations. Closest to \name is a DGP approach proposed by 
L\"ammel et al.~\cite{lammel00dealing} for dealing with so-called
``\emph{large bananas}''. A large banana corresponds to the fold
algebra of a complex structure. Object algebras, which we use in our 
work, are an OO encoding of fold algebras~\cite{Oliveira08visitor,bruno12oa}.
However L\"ammel et al. work has not dealt with extensibility. Interestingly 
in their future work  L\"ammel et al. did mention that they would like ``to cope 
with incomplete or extensible systems of datatypes''. 

\tijs{Bruno: should we add this one: \cite{lammel2002typed}}


\begin{comment} 
In that
approach for generalized and basic folds. These fold algebras scale up
applications involving large systems of mutually recursive
datatypes. These works all try to optimize traversal control of large
structures in functional programming paradigm, while our work solves a
similar problem in Object Algebras, a programming style in Object
Oriented Programming paradigm.
\end{comment}

\paragraph{Object Algebras.} \name traversals are based on
object algebras~\cite{bruno12oa}. The original motivation for object
algebras was as a design pattern for OO programming that allowed
improved extensibility and modularity of programs.  Using object
algebras it is possible to solve the well-known ``Expression
Problem''~\cite{wadler98expression-problem}.  Later
work~\cite{oliveira13fop,rendel14attributes} has explored the use of
\emph{object algebra combinators}, and generalizations of object
algebras to improve expressiveness and modularity. In particular it
has been claimed that object algebras can be used to do
\emph{feature-oriented programming}~\cite{oliveira13fop}, and to
encode \emph{attribute grammars}~\cite{rendel14attributes}. One domain
where object algebras are especially useful is in the implementation
of (extensible) languages.  The QL language used in our case study is
based on Gouseti et al.~\cite{gouseti14extensible} work. That work
provides a realistic implementation of an extensible
\emph{domain-specific language} using object algebras. In contrast to
our work, previous work on object algebras was mostly motivated by
improved programming support for extensibility and modularity. Our
work shows that object algebras are also useful to solve a different
problem: how to traverse complex structures without boilerplate
code. The combination of extensibility (inherited for free from object
algebras) and structure-shy type-safe traversals also adds a new
dimention to our work that, as far as we know, as not been well explored
previously.

