\section{Introduction}

Many applications require complex recursive data structures. Examples
abound in language processing tools/libraries for programming
languages, domain-specific languages, markup languages like HTML, or
data-interchange languages like XML or JSON. In those applications
Abstract Syntax Trees (ASTs) are the key data structure needed to
model the various constructs of the languages. Such ASTs have various
different types of nodes, which can range from a few dozen to
several hundred nodes (for example in the AST of languages like Java).

Static types are helpful to deal with such complex structures.  With
static types it is easy to distinghish between different kinds of
nodes. Furthermore the distinctions are helpful to ensure that
traversals over these structures have an appropriate piece of code that
deals with each different type of node. This can prevent a large class
of run-time errors that would not otherwise be detected.

%For example static types prevent errors that would arize from
%applying the code intended for a certain kind of node to another kind
%of node. Static types can also ensure that all nodes are dealt with by
%an appropriate piece of code.

Unfortunately, for many traversals, the number of nodes and the
enforced type distinctions between nodes can lead to so-called
boilerplate code~\cite{ralf03syb}. In this context, boilerplate code
is code that is similar for most different types of nodes and which
essentially walks the structure. Traversals where such boilerplate
code dominates are called \emph{structure shy}~\cite{DemeterBook}. In
structure shy operations only for a small portion of nodes the code
for the core functionality that motivated the traversal in the first
place will be different. A typical example would be computing the free
variables of an expression for some programming language. In this
case, the interesting code would be done in the nodes representing the
binding constructs. In all other nodes, the code would just deal with
walking the structure. In data structures with dozens or hundreds of
nodes, having to explictly write cases for each node is a source of
significant complexity, since it requires a lot of effort and it is
error-prone.
%In summary, structure shy operations
%suffer from the static typing discipline, because the type
%distinctions between different kinds of nodes leads to significant
%boilerplate code.

It is possible to avoid boilerplate code in languages that support
some kind of reflection~\cite{}, or using some meta-programming
techniques~\cite{}.  With such approaches a programmer only needs to
define the code to deal with the nodes that are not structure
shy. This has important benefits. Firstly the user has to write much
less code, also removing the possibility of errors in the code walking
the structure. Secondly the code becomes much more adaptive to
changes: if structural changes occur only in the structure shy cases,
then the user-defined code remains unchanged.\bruno{Mention some
  concrete examples here, or at least cite them.}  However such
approaches are usually done at the cost of type-safety. For example,
the use of mechanisms such as Java's dynamic reflection comes at the
cost of allowing some run-time errors to occur. Moreover dynamic
reflection usually incurs on significant performance penalties.
Therefore an important challenge is how to make type-safety and structure 
shyness co-exist.\bruno{Talk about SyB.}

This paper presents a Java framework called \name that allows users to
define \emph{type-safe structure-shy operations}. \name uses
\emph{object algebras} to describe complex data structures. Object
algebras are a recently introduced technique, which has been shown to
have significant advantages for software extensibility.  In \name
object algebras interfaces are combined with java annotations to
generate generic and reusable object algebras that deal with
boilerplate traversal code.  Those object algebras include different
types of queries and transformations\bruno{more detail?}.  Programmers
that want to implement structure shy traversals can inherit the
generic traversal code, and focus only on writing the interesting
parts of the traversals. Consequently, the amount of code that
programmers need to write is significantly smaller, and traversals
written in \name are:

\begin{itemize}

\item {\bf Adaptive and structure shy:} \name traversals can omit boilerplate
code, allowing these traversals to be more adaptive to future changes in the 
data structure.

\item {\bf Simple and general:} \name traversals work for any
  structure that can be expressed as a (multi-sorted) object
  algebra. This includes complex OO hierarquies or ASTs for large
  languages. Very often traversals are quite simple, being
  implementable in just a few lines of code, even for complex
  structures with hundreds of different types of nodes.

\item {\bf Implemented in plain Java:} \name traversals do not require
  a new tool or language. The approach is library based and uses only
  Java annotations. 

\item {\bf Type-safely reusable:} With \name traversals all reuse is
  type-safe. No run-time casts are needed for generic traversal code
  or for user-defined traversal code.

\item {\bf Separatly compilable:} \name traversals support separate 
  compilation. 

\item {\bf Extensible:} \name traversals inherit type-safe
  extensibility from object algebras. Both traversals and structures
  are extensible. Therefore it is possible to
  reuse traversal code in structures that are extended with additional
  constructors.

%\item {\bf Performant:} Traversals written with \name have performance that 
%is comparable to naive hand-written OO code.

\end{itemize}

To prove the effectiveness of the approach, we employeed \name 
on the implementation of the domain-specific questionaire 
language QL~\cite{gouseti14extensible}\bruno{hot to format QL properly in latex?}. 
Our results show that for a large number of traversals 
there was a significant reduction in the amount of user-defined code, and no
performance penalties.

Although we have chosen Java as the implementation language for \Name,
our approach should apply to any OO language with support for generics
and annotations (or other built-in macro or meta-programming techniques). 
For example it should be easy to port \name to languages such as Scala, 
or .Net languages.

\begin{comment}

Existing work: 

dynamic approaches: they can offer adaptivity and 
structure shyness, but lack type-safety.

static approaches: No fully type-safe approach that we know 
of for Java. Some approaches that rely on reflection and/or casts.
But these can have run-time type-errors and performance can be 
quite bad. 
Some static type-safe in the functional programming community, 
but cannot be easily ported to Java (rely on sophisticated type 
system features; target algebraic datatypes; ...). Moreover 
(with a few exceptions) most approaches do not offer extensibility. 

Static types are useful to distinguish between different kinds
of nodes in a structure and to prevent misuses. The
distinction between different types of nodes also means that code for
dealing with each type of node is needed. However, in large structures, 
such as the Abstract Syntax Tree (AST) of a programming language, 
the amount of required code can be a problem. For some operations, 
which traverse large structures, most of the code amounts to recursively 
delegating the traversal to the child nodes. Only for some nodes 
of the structure the code needs to do something different. Still 
the programmer needs to diligently and tediously write the error-prone 
traversal code for all nodes.

In this paper we present a framework 

This approach works well for many operations,
which need different (and non-trivial) code for each different type 
of node 

%Unfortunately, for some operations the interesting 

%%In large structures, 
%%such as the Abstract Syntax Tree (AST) of a programming language, 
%%the code required to traverse the whole structure is proportionaly large.


The problem is particularly prominent 
in statically typed languages, where the typing discipline 
enforces strict distinctions between different cases 

Operations that traverse complex structures often require large and 
tedious amounts of boilerplate code. In those operations there are 
typically a few 

A pervasive problem in programming occurs when large tree tr

\end{comment}

In summary, the contributions of this paper are:

\begin{itemize}

\item {\bf Design patterns for generic traversals.} We provide a set of design 
patterns for various types of traversals using object algebras. These include: 
\emph{queries}, \emph{transformations},
\emph{generalized queries} and \emph{generalized transformations}.
\bruno{Come back to this later, when we know which types of traversals we are
presenting.}

\item {\bf The Shy Java framework.} We have implemented 
a Java framework that can be used to describe complex structures using 
object algebras; and to eliminate boilerplate code. The framework uses Java 
annotations to automatically generate generic traversals, and is publicly available
\footnote{\url{www.???.???}}.

\item {\bf Case study and empirical evaluation.} We evaluate the approach using 
a case study based on a domain-specific language for questionaires. The results 
of our case study show significant savings in terms of user-defined traversal code.

\end{itemize}
