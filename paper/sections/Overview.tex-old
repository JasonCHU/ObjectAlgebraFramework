
\section{Overview}\label{subsec:backgound}

We begin by reconsider the company structure problem raised by \cite{ralf03syb}. A company is divided into departments which in turn have a manager, and consists of a collection of sub-units. A unit is either a single employee or a department. Both managers and ordinary employees are persons receiving a salary. An common OOP programmer may organize the codes like: 

\begin{lstlisting}[numbers=none]
public class Company {
	private List<Department> depts;
	public Company(List<Department> depts){this.depts = depts;}
}
public class Salary {
	private float salary;
	public Salary(float salary){this.salary = salary;}
} 
\end{lstlisting}
Similarly codes may be applied to Department, Employee, etc. Now consider adding two operations to our company structure: query the salary bill for the whole company and increase the salary for the each employee by 10\%. One may decide adding two more functions to all the classes, which is: 
\begin{lstlisting}[numbers=none]
public class Company {
	public float salaryBill(){
		float r = 0; 
		for (Department dept: depts) r+= dept.salaryBill(); 
		return r;
	}
	public void increaseSalary(){
		for (Department dept: depts) dept.increaseSalary();
	}
}
public class Salary {
	public float salaryBill(){return this.salary;}
	public void increaseSalary(){this.salary *= 1.1;}
}
\end{lstlisting}



This way of OOP style representation of tree structures can become cumbersome and inflexible due to the hard relationship between classes. For example, adding a new operation such as pretty printing of the company structure requires a lot of changes on the existing codes and violates the no modification rule. One can solve this problem by coding with object algebras as Figure~\ref{syb_tree}: 
\begin{figure}[tb]
\lstinputlisting[linerange=10-18]{../ObjectAlgebras/src/trees/SybAlg.java} % APPLY:linerange=SYB_TREE
\vspace{-.1in}
\caption{Company Structure represented by Object Algebra Interface}
\label{syb_tree}
\end{figure}

Hence different operations can be realized by inheriting object algebras from object algebra interface. For query salary bill: 
\begin{lstlisting}
public class SalaryQuerySybAlg implements SybAlg<Float,Float,Float,Float,Float,Float> {
	public Float C(List<Float> depts){
		Float r = 0f;
		for (Float f: depts) r += f;
		return r;
	}
	public Float S(float salary){
		return salary;
	}
}
\end{lstlisting}
Increasing Salary is trickier: 
\begin{lstlisting}
public interface G_Company {
	<Company,Dept,SubUnit,Employee,Person,Salary> Company accept(SybAlg<Company,Dept,SubUnit,Employee,Person,Salary> alg);
}
public interface G_Salary {
	<Company,Dept,SubUnit,Employee,Person,Salary> Salary accept(SybAlg<Company,Dept,SubUnit,Employee,Person,Salary> alg);
}
public class IncreaseSalarySybAlg implements SybAlg<G_Company, G_Dept, G_SubUnit, G_Employee, G_Person, G_Salary>{
	@Override
	public  G_Company C(List<G_Dept> p0) {
		return new G_Company() {
			public <Company,Dept,SubUnit,Employee,Person,Salary> Company accept(SybAlg<Company,Dept,SubUnit,Employee,Person,Salary> alg) {
				List<Dept> gp0 = new ArrayList<Dept>();
				for (G_Dept s: p0) {
					gp0.add(s.accept(alg));
				}
				return alg.C(gp0);
			}
		};
	}
	public  G_Salary S(float p0) {
		return new G_Salary() {
			@Override
			public <Company,Dept,SubUnit,Employee,Person,Salary> Salary accept(SybAlg<Company,Dept,SubUnit,Employee,Person,Salary> alg) {
				return alg.S(1.1f*p0);
			}
		};
	}
}
\end{lstlisting}

However, although we solved the problem of extensibility with object algebra, these traversal codes become so long and most of the time we are writing boilerplate routine traversal codes. The only code we are really interested in is the Salary S(Float salary) function for salary. It will be great if those boilerplate codes can be generated automatically every time we want to traversal the tree structure. 

Motivated by this problem of generating generic codes for tree structure traversals, more specifically, queries and transformations in object algebras, we designed an object algebra framework with great features. We introduce monoids in queries and generic visitable interfaces in transformations, and write generic query and transformation which can be easily inherited by real cases of queries and transformations. Furthermore, even the generic query and transformation codes can be generated automatically by adding an ``$@$Algebra'' annotation. 
