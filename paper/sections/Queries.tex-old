\section{Queries}\label{sec:queries}

This section shows the ideas behind generic queries and how they are
implemented in \Name. A query is an operation that traverses a
structure and computes some aggregate value. The inspiration for
queries comes from similar types of traversals used in functional
programming libraries, such as ``Scrap your Boilerplate''~\cite{ralf03syb}.
Queries are illustrated using a simple type of expressions with
variables, where the goal is to implement the free variables in an expression.

\begin{comment}
As a specific type of object algebras, queries allow users to define
new operations handling a user-defined data structure\bruno{This
  definition of queries is just too broad. Please
look at papers like Syb to see how they describe queries and transformations}. A \textit{query
  algebra} is a class implementing an object algebra interface by a
top-down traversal throughout the hierarchy. It is something
supporting the program to gather information from the substructures of
a data type recursively, and make a response at the root node to the
query.
\end{comment}

\subsection{Free Variables: A Simple Query Algebra}\label{subsec:freevars}

\begin{figure}[!htbp]
\lstinputlisting[linerange=6-11]{../ObjectAlgebras/src/trees/ExpAlg.java} % APPLY:linerange=EXP_ALG
\vspace{-.1in}
\caption{Object algebra interface: \lstinline{ExpAlg}}
\label{exp_alg}
\end{figure}

Figure~\ref{exp_alg} shows a simple type of expressions, represented 
as an object algebra interface. Note that we use this minimal object
algebra interface throughout the rest of the paper to illustrate the various different
types of traversals supported by \Name. 

Three different kinds of nodes exist:
a numeric literal, a variable or the addition of
two expressions. 

Based the interface above, a query might be raised on collecting
all the names of free variables defined in an expression. More
precisely, a list of strings would be used to store the names of
those variables. In that case, a \lstinline{Var(s)} would simply return a singleton list of \lstinline{s}, and a \lstinline{Lit(i)} corresponds to an empty list, whereas two lists would be joined into one if we are combining two
expressions with the \lstinline{Add()} method.

Generally speaking, it is natural to deal with the traversal in an algebra-based approach like Fig.~\ref{freevars_without_monoid}.

\begin{figure}[tb]
\lstinputlisting[linerange=12-18]{../ObjectAlgebras/src/expDemo2/FreeVarsExpAlg.java} % APPLY:linerange=FREEVARS_WITHOUT_MONOID
\vspace{-.1in}
\caption{A normal algebra-based approach for freeVars}
\label{freevars_without_monoid}
\end{figure}
\begin{comment}
\bruno{put code in a figure, add a caption and refer
  to the figure in the text.}
\end{comment}

Information on our query is collected by traversal and passed on to a
higher-level structure. Nonetheless, a programmer has to write a lot
of boring code handling the traversals, and it could be even worse for
a more complicated data structure. Moreover, it is a query-based
approach: you still have to write a bunch of similar stuff with a
different query raised, for instance, a pretty printer.

\subsection{Generic query algebra with a monoid}\label{subsec:genericquery}

Queries are so similar actually: a user has to indicate the rules in
which the program may address cases on primitive types and ``append''
the information. With these two issues, everything becomes simple in
the traversal. Hence we introduce the concept of monoid and generic
traversal here in our query algebras.

\begin{figure}[tb]
\lstinputlisting[linerange=6-12]{../ObjectAlgebras/src/expDemo3/Monoid.java} % APPLY:linerange=MONOID
\vspace{-.1in}
\caption{A generalized monoid interface}
\label{monoid}
\end{figure}

The interface of a monoid is defined in Fig.~\ref{monoid}. Intuitively, the \lstinline{join()}
method implies how we combine the information from substructures during
merging, and the \lstinline{empty()} is just an indicator of ``no
information''. Hence now we are able to write a ``generic traversal''
manually based on monoids. See Fig.~\ref{generic_query}.
\begin{comment}
\bruno{As you can see, nothing
  follows! Please refer to the figure instead and briefly explain the
  code in the figure.}
\end{comment}

\begin{figure}[tb]
\lstinputlisting[linerange=4-9]{../ObjectAlgebras/src/expDemo3/ExpAlgQuery.java} % APPLY:linerange=GENERIC_QUERY
\vspace{-.1in}
\caption{Generic query by hand with monoid}
\label{generic_query}
\end{figure}

And now we find everything goes in an easier way: we don't care about what kind of query it is any more during the traversal. Despite whether it asks for all the names of free variables or a printer showing the hierarchy of an expression, at first we can simply override the method \lstinline{m()}, which provides an instance of \lstinline{Monoid}, in the return statement. As the next step, we only need to override a few other methods to meet the requirements. This is the progress, once we have such a template dealing with the traversal, all query algebras can be addressed in a more concise way, which is called the \textit{generic query algebra}.

\subsection{Solving freeVars with generic query algebra}\label{subsec:solvingfreevars}

As an alternative way to handle the freeVars query, the query algebra is going to be a sub-interface of \lstinline{ExpAlgQuery}, the generic algebra, with generic type to be \lstinline{List<String>}. To use the generic traversal code, a monoid is defined in Fig.~\ref{freevars_monoid}.

\begin{figure}[tb]
\lstinputlisting[linerange=9-14]{../ObjectAlgebras/src/expDemo3/FreeVarsMonoid.java} % APPLY:linerange=FREEVARS_MONOID
\vspace{-.1in}
\caption{A monoid instance defined for freeVars}
\label{freevars_monoid}
\end{figure}
\bruno{Is an array the best structure to use here?
  Wouldn't a vector or list be better? The simpler the code is, the better.}

But the result for an expression can only be a null list based on the monoid. Thus in the freeVars query, furthermore, we expect the variables to store their names into a list, and by using the monoid, freeVars can be implemented. See Fig.~\ref{freevars_with_monoid}.

\begin{figure}[tb]
  \lstinputlisting[linerange=8-11]{../ObjectAlgebras/src/expDemo3/FreeVarsExpAlg.java} % APPLY:linerange=FREEVARS_WITH_MONOID
\vspace{-.1in}
\caption{The query interface for freeVars}
\label{freevars_with_monoid}
\end{figure}

When the interface \lstinline{FreeVarsExpAlg} is used, an object of the \lstinline{FreeVarsMonoid} is then created. As we can see, it is needless for a user to write an exclusive traversal fully for a data structure. Nothing but a monoid is required together with a few methods being overwritten. And furthermore, a monoid can usually be shared among query algebras with the same data type.
