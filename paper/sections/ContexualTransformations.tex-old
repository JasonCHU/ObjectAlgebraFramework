\section{Contextual Transformations}\label{sec:contexttrans}

In the previous section, our identity approach introduces a simple template for transformations. When a transformation algebra is requested, users can just override some of the methods, to avoid building up the complete framework for traversals, which can be quite complicated with boring code. Moreover, we mention that transformation algebras show up like a transformation pipeline, and once a query is passed to the pipeline, all the information is visited, processed and integrated exactly along with the construction. However, some other transformations are special, in the sense that they work in a different way. They are called \textit{contextual transformations}. Literally, they need to deal with the context in a data structure.

We can see in the previous transformation algebras, namely ``non-contextual'' ones according to our classification, that those methods in an algebra usually work separately, share no information and hence we handle them as different cases. But in other situations, we may need to interact with the context, and propagate some additional information everywhere accordingly.

\subsection{Capture-avoiding substitution: a contextual transformation}\label{subsec:captureavoidsubst}

A good example for the contextual transformation, is the \textit{capture-avoiding substitution} (SUBST, for convenience). \haoyuan{citation needed.} The SUBST is distinguished from our previous substitution algebra, in the sense that, for example, with an extension to the \lstinline{ExpAlg}, including lambda expressions and applications, the substitution should be able to avoid variable capture problems. As our object algebra interface is flexible with high extensibility, we create a new interface here as the extension to \lstinline{ExpAlg}. See Fig.~\ref{lam_alg}.

\begin{figure}[!htbp]
\lstinputlisting[linerange=-]{} % APPLY:linerange=-LAM_ALG
\vspace{-.1in}
\caption{Object algebra interface: LamAlg}
\label{lam_alg}
\end{figure}

Now our expression algebra also supports lambdas and applications. So when we want to substitute a specified variable to a new expression, we shall be careful that those free variables should not be captured when replacement is applied. This is to preserve the equivalence in semantics during substitution.

An algorithm for SUBST is given by (\haoyuan{citation}). The idea is that, besides the variable and the substitutive expression, we should always maintain a set of free variables, as well as a mapping for renaming during a top-down traversal. Here we see the difference from some common transformations: we are passing additional information among substructures from top to the bottom, and update it sometimes according to the context inside.

We give a representative approach here as usual, which solves SUBST with respect to transformation algebras.

\subsection{Generic traversal for contextual transformations}\label{subsec:genericcontexttrans}

\subsection{Solving SUBST with generic transformation algebra}\label{subsec:solvingsubst}