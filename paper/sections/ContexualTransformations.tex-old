\subsection{Contextual Transformations}\label{sec:contexttrans}

The previous section introduced a simple template for defining transformations that execute during construction of a structure (e.g., an expression).
Transformations in this style can only depend on global context information (e.g., \lstinline{x()}, \lstinline{e()}).
Many transformations, however, require context information that depends on the traversal itself.
\tijs{Fix this sentence}
Here we show how to eliminate boilerplate from such transformation b...  by constructing functions that build into an algebra.


\subsection{Conversion to De Bruijn indices: contextual transformation}

An example of a contextual transformation is replacing variables  to De Bruijn indices in the lambda calculus.
Using De Bruijn indices, a variable occurrence is identified by a natural number equal to the number of $\lambda$ terms between the variable occurrence and its binding lambda term.
Lambda terms expressed using De Bruijn indices are useful because they are invariant with respect to alpha conversion.


\begin{figure}[t]
\lstinputlisting[linerange=12-22]{../ObjectAlgebras/src/debruijn/DeBruijn.java} % APPLY:linerange=DEBRUIJN
\vspace{-.1in}
\caption{Converting variables to De Bruijn indices}
\label{DeBruijn}
\end{figure}



\subsection{Generic traversal for contextual transformations}\label{subsec:genericcontexttrans}

Again, one may also come up with the same question: can we also generalize the procedure of traversals, just like the generic transformations that we discussed before? The answer is yes.

Fig.~\ref{context_trans_expalg} and Fig.~\ref{context_trans_lamalg} show the generic transformation code for \lstinline{ExpAlg} and \lstinline{LamAlg}, respectively. They are inspired from the identity approach as well. Both interfaces have two generic types A and B, where A specifies the type of the information we are to propagate, and B actually corresponds to \lstinline{expAlg()} and \lstinline{lamAlg()}. They are the algebras that a transformation follows with the identity approach. Therefore, here the generic type for \lstinline{ExpAlg} and \lstinline{LamAlg} is \lstinline{Function<A, B>}. For the contextual transformations that refer to a data structure with multiple generic types, we may have various return types and the \lstinline{Function} instance could be curried.

\begin{figure}[tb]
\lstinputlisting[linerange=6-17]{../ObjectAlgebras/src/example_LamAlg2/G_ExpAlgTransform.java} % APPLY:linerange=CONTEXT_TRANS_EXPALG
\vspace{-.1in}
\caption{Generic contextual transformation by hand for \lstinline{ExpAlg}}
\label{context_trans_expalg}
\end{figure}

\begin{figure}[tb]
\lstinputlisting[linerange=6-14]{../ObjectAlgebras/src/example_LamAlg2/G_LamAlgTransform.java} % APPLY:linerange=CONTEXT_TRANS_LAMALG
\vspace{-.1in}
\caption{Generic contextual transformation by hand for \lstinline{LamAlg}}
\label{context_trans_lamalg}
\end{figure}

As we can see, there are two identity transformation algebras for \lstinline{ExpAlg} and \lstinline{LamAlg}, respectively. And a user can simply override some of the methods instead of write a lot of boilerplates for traversals, which could be even worse with a complicated structure.

