\section{Contextual Transformations}\label{sec:contexttrans}

The previous section introduced a simple template for defining transformations that execute during construction of a structure (e.g., an expression).
Transformations in this style can only depend on global context information (e.g., \lstinline{x()}, \lstinline{e()}).
Many transformations, however, require context information that depends on the traversal itself.
\tijs{Fix this sentence}
Here we show how to eliminate boilerplate from such transformation b...  by constructing functions that build into an algebra.

The solution is the same is in the non-contextual transformation sof the previous sub-section: a generic super interface captures the general traversal strategy
However, instead of having the algebra methods delegate directly to base algebra (e.g., \lstinline{expAlg()}), this now happens indirectly through a closure that propagates the context information.

Figure~\ref{ctxTrafoTemplate} shows the general template for an \lstinline{Alg<X1, X2, ..., Xn>}, with constructors \lstinline{f1, ..., fm}.
Note that it extends \lstinline{Alg} and instantiates the type parameter to \lstinline{Function} types, from the context argument \lstinline{C} to the corresponding sort \lstinline{X}$_i$. 
Each constructor method now creates an anonymous function which, when invoked, calls the functions received as parameters (\lstinline{p}$_1$ to \lstinline{p}$_k$) and only then creates a structure over the \lstinline{alg} algebra.

\begin{figure}[t]
\begin{lstlisting}[mathescape=true]
interface Alg$_T$<C,X$_1$,$...$,X$_n$> extends Alg<Function<C,X$_1$>,$...$,Function<C,X$_n$>> {
  Alg<X$_1$, ..., X$_n$> alg();

  default Function<C, X$_i$> f$_j$(Function<C,X$^1_p$> p$_1$, $...$, Function<C,X$^k_{q}$> p$_k$) {
    return  (c) -> alg().f$_j$(p$_1$.apply(c), $...$, p$_k$.apply(c));
  }
  $...$
}
\end{lstlisting}
\caption{Generic template for generating boilerplate of contextual transformations}
\label{ctxTrafoTemplate}
\end{figure}

\subsection{Example: conversion to De Bruijn indices}

The template shown in Fig.~\ref{ctxTrafoTemplate} support tranformations where traversal dependent context informations flows down the created structure.
An example of such a contextual transformation is replacing variables  to De Bruijn indices in the lambda calculus~\cite{DeBruijn}.
Using De Bruijn indices, a variable occurrence is identified by a natural number equal to the number of $\lambda$ terms between the variable occurrence and its binding lambda term.
Lambda terms expressed using De Bruijn indices are useful because they are invariant with respect to alpha conversion.

To implement the conversion to De Bruijn indices we assume an expression interface \lstinline{LamAlg} with constructors for lambda abstraction (\lstinline{Lam}) and application (\lstinline{App}).
This interface can be used together with the \lstinline{ExpAlg} interface introduced ealier \tijs{TODO: where?}.
Furthermore we assume that the generic template shown in Fig.~\ref{ctxTrafoTemplate} is instantiated for both interfaces as \lstinline{G_LamAlgTransform} and \lstinline{G_ExpAlgTransform} respectively.
Using these interface, the conversion to De Bruijn indices can be realized as shown in Fig.~\ref{DeBruijn}.
Note again that only the relevant cases are overridden: \lstinline{Var} (from \lstinline{ExpAlg}) and \lstinline{Lam} (from \lstinline{LamAlg}).



\begin{figure}[t]
\lstinputlisting[linerange=12-20]{../ObjectAlgebras/src/debruijn/DeBruijn.java} % APPLY:linerange=DEBRUIJN
\vspace{-.1in}
\caption{Converting variables to De Bruijn indices}
\label{DeBruijn}
\end{figure}




