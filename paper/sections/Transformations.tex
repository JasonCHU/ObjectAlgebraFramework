\section{Transformations}\label{sec:transformations}
\label{retroimp}

Besides the collection of information, one may also want to modify the information under some circumstances, by which transformation is inspired. Transformation is another essential type of object algebras with respect to query. Whereas a programmer unavoidably should also write a bunch of boilerplate code traversing the structure make some changes.

\subsection{SubstVars: a simple tranformation algebra}\label{subsec:substvars}

An example of the transformation algebra, based on the interface ExpAlg is called \textit{substVars}. We anticipate to substitute a given expression for a specific variable. To address this issue, a programmer who has knowledge of object algebras may usually write some traversal code like Fig.~\ref{substvars_without_id}.

\begin{figure}[!htbp]
\lstinputlisting[linerange=-]{} % APPLY:linerange=SUBSTVARS_WITHOUT_ID
\vspace{-.1in}
\caption{A normal algebra-based approach for substVars}
\label{substvars_without_id}
\end{figure}

In Fig.~\ref{substvars_without_id}, \lstinline{getVar()} is the name of the specified variable, and \lstinline{getExp()} is the substitution. \lstinline{expAlg()} is an instance of \lstinline{ExpAlg} on which the transformation is based. Here comes the same problem. The boilerplate code consists of a particular traversal, with implementing all methods in the algebra interface to fulfill the requirements. It implies redundant work for a different transformation.

\subsection{The identity approach}\label{subsec:idapproach}

In the section of query algebras, we introduce monoids to implement the generic traversal of an object algebra interface. And similarly, the technique to achieve the generic traversal on transformations is called the \textit{identity approach}.

\begin{figure}[!htbp]
\lstinputlisting[linerange=-]{} % APPLY:linerange=GENERIC_TRANSFORM
\vspace{-.1in}
\caption{Generic transformation by hand with identity approach}
\label{generic_transform}
\end{figure}

Fig.~\ref{generic_transform} shows the generic transformation code of \lstinline{ExpAlg} with our identity approach. This class takes an algebra as the incoming argument, and works exactly in the same way as the algebra. In this way transformations become independent of queries, holding the modularity as expected. And though this class is actually doing nothing, a user can simply override some of the methods and get a certain transformation algebra.

Another important characteristic is that we can apply several transformations to the data structure before a query. This pattern is called the \textit{transformation pipeline}. Since the transformation algebra \lstinline{ExpAlgTransform<Exp>} is a sub-interface of \lstinline{ExpAlg<Exp>}, it creates any instance with the same type as the \lstinline{expAlg()} inside. Therefore a programmer can define a number of transformation algebras, and compose them in sequence, like a nested structure. At the meantime, a query algebra is passed to the innermost \lstinline{expAlg()}. In that case, the query is traversed recursively throughout the pipeline and eventually derives a certain composite transformation algebra.

\subsection{Solving substVars with generic transformation algebra}\label{subsec:solvingsubst}

Now with our generic transformation, one solution to substVars is available in Fig.~\ref{substvars_with_id}, where the method \lstinline{Var()} from its super-interface \lstinline{ExpAlgTransform} is overridden.

\begin{figure}[!htbp]
\lstinputlisting[linerange=-]{} % APPLY:linerange=SUBSTVARS_WITH_ID
\vspace{-.1in}
\caption{The transformation interface for substVars}
\label{substvars_with_id}
\end{figure}

The \lstinline{SubstVarsExpAlg} is still generic, yet something like a pretty printer can be passed to the \lstinline{expAlg()} inside as a query, to display the results. Hence at this moment, a programmer doesn't need to write boilerplate code for traversals. The identity approach and the pipeline of transformations provide users with a generic transformation like a template.
